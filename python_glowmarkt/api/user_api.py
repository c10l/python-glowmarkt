# coding: utf-8

"""
Glowmarkt User System

The document enlists and describes the APIs for the User.  # noqa: E501

OpenAPI spec version: 1.0.5

Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from python_glowmarkt.api_client import ApiClient


class UserApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_user(self, **kwargs):  # noqa: E501
        """Create a user  # noqa: E501

        Create a User a directory account for username and password login using this action. More specifically this is a registration process which creates a user and adds an account to the given application id. Self-Registration process should use this action. This call requires no authentication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_user(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddUserReq body: The information that is used to create a user.
        :return: AddUserRes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.add_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_user_with_http_info(self, **kwargs):  # noqa: E501
        """Create a user  # noqa: E501

        Create a User a directory account for username and password login using this action. More specifically this is a registration process which creates a user and adds an account to the given application id. Self-Registration process should use this action. This call requires no authentication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_user_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddUserReq body: The information that is used to create a user.
        :return: AddUserRes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s' to method add_user" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/register",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AddUserRes",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def create_user(self, **kwargs):  # noqa: E501
        """Create a user  # noqa: E501

        This call can be used by an application to create a user. No verification will be required  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateUserReq body: The information that is used to create a user.
        :return: CreateUserRes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.create_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_user_with_http_info(self, **kwargs):  # noqa: E501
        """Create a user  # noqa: E501

        This call can be used by an application to create a user. No verification will be required  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateUserReq body: The information that is used to create a user.
        :return: CreateUserRes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["appKeys", "applicationId", "devUserToken", "orgAppKeys"]  # noqa: E501

        return self.api_client.call_api(
            "/user",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CreateUserRes",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def delete_userby_id(self, user_id, **kwargs):  # noqa: E501
        """Delete specific user. This will delete all the accounts of a user. Please refer to delete account API. This API requires specific permissions.  # noqa: E501

        Deletes a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_userby_id(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID of user that is being queried (required)
        :return: IsValidRes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_userby_id_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_userby_id_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_userby_id_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete specific user. This will delete all the accounts of a user. Please refer to delete account API. This API requires specific permissions.  # noqa: E501

        Deletes a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_userby_id_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID of user that is being queried (required)
        :return: IsValidRes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["user_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_userby_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'user_id' is set
        if "user_id" not in params or params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `delete_userby_id`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "user_id" in params:
            path_params["userId"] = params["user_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["appKeys", "applicationId", "devUserToken", "orgAppKeys"]  # noqa: E501

        return self.api_client.call_api(
            "/user/{userId}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="IsValidRes",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def generate_user_password_reset_token(self, **kwargs):  # noqa: E501
        """Generate a token that can be used by user to reset their password.  # noqa: E501

        This call generates a 4 digit token and sends it via second channel of communication over to the user (at the moment the only second channel of communication supported is email). The user can then use this token to reset their password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_user_password_reset_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GeneratePasswordResetTokenUserReq body: The information that is needed to generate a password reset token.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.generate_user_password_reset_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.generate_user_password_reset_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def generate_user_password_reset_token_with_http_info(self, **kwargs):  # noqa: E501
        """Generate a token that can be used by user to reset their password.  # noqa: E501

        This call generates a 4 digit token and sends it via second channel of communication over to the user (at the moment the only second channel of communication supported is email). The user can then use this token to reset their password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_user_password_reset_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GeneratePasswordResetTokenUserReq body: The information that is needed to generate a password reset token.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_user_password_reset_token" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/user/resetpassword",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="InlineResponse2001",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def generate_user_verification_token(self, **kwargs):  # noqa: E501
        """Generate a user verification token  # noqa: E501

        This call generates a 4 digit token and sends it via second channel of communication over to the user (at the moment the only second channel of communication supported is email).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_user_verification_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GenerateVerificationTokenUserReq body: The information that is used to create to generate an email verification token.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.generate_user_verification_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.generate_user_verification_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def generate_user_verification_token_with_http_info(self, **kwargs):  # noqa: E501
        """Generate a user verification token  # noqa: E501

        This call generates a 4 digit token and sends it via second channel of communication over to the user (at the moment the only second channel of communication supported is email).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_user_verification_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GenerateVerificationTokenUserReq body: The information that is used to create to generate an email verification token.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_user_verification_token" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/user/verify",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="InlineResponse2001",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_userby_id(self, user_id, **kwargs):  # noqa: E501
        """Find specific user that has an account in an application.  # noqa: E501

        Returns a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_userby_id(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID of user that is being queried (required)
        :return: AddUserRes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_userby_id_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_userby_id_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_userby_id_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Find specific user that has an account in an application.  # noqa: E501

        Returns a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_userby_id_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID of user that is being queried (required)
        :return: AddUserRes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["user_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_userby_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'user_id' is set
        if "user_id" not in params or params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `get_userby_id`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "user_id" in params:
            path_params["userId"] = params["user_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["appKeys", "applicationId", "devUserToken", "orgAppKeys"]  # noqa: E501

        return self.api_client.call_api(
            "/user/{userId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AddUserRes",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_userby_username(self, username, **kwargs):  # noqa: E501
        """Find specific user that has an account in an application from the username.  # noqa: E501

        Returns a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_userby_username(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: The username of user that is being queried (lowercase, trimmed etc). Please note that this API is prone to errors if the username contains characters that are affected by URL encoding. (required)
        :return: AddUserRes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_userby_username_with_http_info(username, **kwargs)  # noqa: E501
        else:
            (data) = self.get_userby_username_with_http_info(username, **kwargs)  # noqa: E501
            return data

    def get_userby_username_with_http_info(self, username, **kwargs):  # noqa: E501
        """Find specific user that has an account in an application from the username.  # noqa: E501

        Returns a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_userby_username_with_http_info(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: The username of user that is being queried (lowercase, trimmed etc). Please note that this API is prone to errors if the username contains characters that are affected by URL encoding. (required)
        :return: AddUserRes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["username"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_userby_username" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'username' is set
        if "username" not in params or params["username"] is None:
            raise ValueError(
                "Missing the required parameter `username` when calling `get_userby_username`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "username" in params:
            query_params.append(("username", params["username"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["appKeys", "applicationId", "devUserToken", "orgAppKeys"]  # noqa: E501

        return self.api_client.call_api(
            "/user",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="AddUserRes",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def reset_password_user(self, **kwargs):  # noqa: E501
        """A user resets their password  # noqa: E501

        This call generates a 4 digit token and sends it via second channel of communication over to the user (at the moment the only second channel of communication supported is email).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_user(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PasswordResetUserReq body: The information that is used to reset a user's password.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.reset_password_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.reset_password_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def reset_password_user_with_http_info(self, **kwargs):  # noqa: E501
        """A user resets their password  # noqa: E501

        This call generates a 4 digit token and sends it via second channel of communication over to the user (at the moment the only second channel of communication supported is email).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_user_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PasswordResetUserReq body: The information that is used to reset a user's password.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password_user" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/user/resetpassword",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="InlineResponse2001",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def update_username_user_id(self, user_id, **kwargs):  # noqa: E501
        """Change a user's username  # noqa: E501

        API to update a user's username  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_username_user_id(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID of user that is being queried (required)
        :param UserIdUsernameBody body: The body contains the user's new email.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.update_username_user_id_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_username_user_id_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def update_username_user_id_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Change a user's username  # noqa: E501

        API to update a user's username  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_username_user_id_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: ID of user that is being queried (required)
        :param UserIdUsernameBody body: The body contains the user's new email.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["user_id", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_username_user_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'user_id' is set
        if "user_id" not in params or params["user_id"] is None:
            raise ValueError(
                "Missing the required parameter `user_id` when calling `update_username_user_id`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "user_id" in params:
            path_params["userId"] = params["user_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["applicationId", "userToken"]  # noqa: E501

        return self.api_client.call_api(
            "/user/{userId}/username",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="InlineResponse2001",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def verify_user(self, **kwargs):  # noqa: E501
        """Verify a user verification token  # noqa: E501

        This call generates a 4 digit token and sends it via second channel of communication over to the user (at the moment the only second channel of communication supported is email).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_user(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VerifyUserReq body: The information that is used to create a devuser.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.verify_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.verify_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def verify_user_with_http_info(self, **kwargs):  # noqa: E501
        """Verify a user verification token  # noqa: E501

        This call generates a 4 digit token and sends it via second channel of communication over to the user (at the moment the only second channel of communication supported is email).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_user_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VerifyUserReq body: The information that is used to create a devuser.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_user" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/user/verify",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="InlineResponse20010",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
